y = .data$fitted_log,
z = .data$rank)),
lo_80 = exp(undiff(x= .data$lo_80,
y = .data$fitted_log,
z = .data$rank)))
View(df_model)
library(ggplot2)
ggplot(data = df_model, aes(x = date, y = close)) +
geom_point(aes(color = training)) + geom_line(aes(y = fitted_actual)) +
geom_ribbon(aes(ymin = lo_95, ymax = hi_95, alpha = 0.2))
ggplot(data = df_model, aes(x = date, y = close)) +
geom_point() + geom_line(aes(y = fitted_actual)) +
geom_ribbon(aes(ymin = lo_95, ymax = hi_95, alpha = 0.2))
?undiff
?diffinv
x = df_model$.fitted
df = data.frame(x=x, y=y, z=z)
num_na = sum(is.na(x)) #this will count how many we need to avoid
na_vec <- rep(NA, num_na-1) #use this to regenerate correct vector at the end.
#grab index value:
index <- dplyr::filter(df, .data$z == (min(.data$z))) %>% #some magic numbers - essentially we want to start at one behind the forecast
dplyr::select(.data$y) %>% unlist()
df <- dplyr::filter(df, !is.na(.data$x))
x <- stats::diffinv(rev(df$x), lag = 10, xi = index)
#grab index value:
index <- dplyr::filter(df, .data$z %in% (min(.data$z):(num_na-1))) %>% #some magic numbers - essentially we want to start at one behind the forecast + lag
dplyr::select(.data$y) %>% unlist()
df = data.frame(x=x, y=y, z=z)
num_na = sum(is.na(x)) #this will count how many we need to avoid
na_vec <- rep(NA, num_na-1) #use this to regenerate correct vector at the end.
#grab index value:
index <- dplyr::filter(df, .data$z %in% (min(.data$z):(num_na-1))) %>% #some magic numbers - essentially we want to start at one behind the forecast + lag
dplyr::select(.data$y) %>% unlist()
df <- dplyr::filter(df, !is.na(.data$x))
x <- stats::diffinv(rev(df$x), lag = 10, xi = index)
x
ts_close
?diff
x
y
#add model fit and forecast back to data frame
df_model <- predic_df %>% dplyr::left_join(df_model) %>%
dplyr::mutate(fitted_actual = exp(undiff(x= .data$.fitted,
y = .data$close_log,
z = .data$rank,
lag = lag)),
fitted_log = undiff(x= .data$.fitted,
y = .data$close_log,
z = .data$rank),
hi_95 = exp(undiff(x = .data$hi_95,
y = .data$fitted_log,
z = .data$rank),),
lo_95 = exp(undiff(x= .data$lo_95,
y = .data$fitted_log,
z = .data$rank)),
hi_80 = exp(undiff(x= .data$hi_80,
y = .data$fitted_log,
z = .data$rank)),
lo_80 = exp(undiff(x= .data$lo_80,
y = .data$fitted_log,
z = .data$rank)))
#add model fit and forecast back to data frame
df_model <- predic_df %>% dplyr::left_join(df_model) %>%
dplyr::mutate(fitted_actual = exp(undiff(x= .data$.fitted,
y = .data$close_log,
z = .data$rank,
lag = lag)),
fitted_log = undiff(x= .data$.fitted,
y = .data$close_log,
z = .data$rank,
lag = lag),
hi_95 = exp(undiff(x = .data$hi_95,
y = .data$fitted_log,
z = .data$rank,
lag = lag)),
lo_95 = exp(undiff(x= .data$lo_95,
y = .data$fitted_log,
z = .data$rank,
lag = lag)),
hi_80 = exp(undiff(x= .data$hi_80,
y = .data$fitted_log,
z = .data$rank,
lag = lag)),
lo_80 = exp(undiff(x= .data$lo_80,
y = .data$fitted_log,
z = .data$rank,
lag = lag)))
devtools::load_all()
devtools::load_all()
df_model <- Quandl::Quandl.datatable('SHARADAR/SEP', date.gte=min_date,
ticker= ticker1) %>%
dplyr::mutate(close_log = log(.data$close),
rank = rank(date))
#tidy this shit up
predic_df <- process_fit(fit = fit, fcast = fcast, df = df_model,
look_ahead = look_ahead)
#add model fit and forecast back to data frame
df_model <- predic_df %>% dplyr::left_join(df_model) %>%
dplyr::mutate(fitted_actual = exp(undiff(x= .data$.fitted,
y = .data$close_log,
z = .data$rank,
lag = lag)),
fitted_log = undiff(x= .data$.fitted,
y = .data$close_log,
z = .data$rank,
lag = lag),
hi_95 = exp(undiff(x = .data$hi_95,
y = .data$fitted_log,
z = .data$rank,
lag = lag)),
lo_95 = exp(undiff(x= .data$lo_95,
y = .data$fitted_log,
z = .data$rank,
lag = lag)),
hi_80 = exp(undiff(x= .data$hi_80,
y = .data$fitted_log,
z = .data$rank,
lag = lag)),
lo_80 = exp(undiff(x= .data$lo_80,
y = .data$fitted_log,
z = .data$rank,
lag = lag)))
rm(list = ls())
ticker = "AAPL"
vendor = "quandl"
look_back = 200
look_ahead = 14
lag = 10
decay = 0.2
ticker1 = ticker #just to avoid any bugs due to non-standard eval
min_date <- Sys.Date() - lubridate::days(look_back)
key <- get_api_key(vendor = vendor)
Quandl::Quandl.api_key(key)
df_model <- Quandl::Quandl.datatable('SHARADAR/SEP', date.gte=min_date,
ticker= ticker1) %>%
dplyr::mutate(close_log = log(.data$close),
rank = rank(date))
#create differenced ts for modeling
ts_close <- diff(zoo::zoo(x = df_model$close_log, order.by = df_model$rank))
#don't want to try to fit if we don't have at least 80% of the points we wanted
if(length(ts_close) < 0.6*look_back) {
message(paste("not enough data to predict", ticker1, date))
return()
}
#fit the model and forecast
fit <- forecast::nnetar(y = ts_close, p = lag, P = 1, decay = decay)
fcast <- forecast::forecast(fit, h = look_ahead, PI=TRUE)
#tidy this shit up
predic_df <- process_fit(fit = fit, fcast = fcast, df = df_model,
look_ahead = look_ahead)
#add model fit and forecast back to data frame
df_model <- predic_df %>% dplyr::left_join(df_model) #%>%
x = df_model$.fitted
y = df_model$close_log
z = df_model$rank
df = data.frame(x=x, y=y, z=z)
num_na = sum(is.na(x)) #this will count how many we need to avoid
na_vec <- rep(NA, num_na-1) #use this to regenerate correct vector at the end.
#grab index value:
index <- dplyr::filter(df, .data$z %in% (min(.data$z):(min(.data$z) + lag))) %>% #some magic numbers - essentially we want to start at one behind the forecast + lag
dplyr::select(.data$y) %>% unlist()
index
#grab index value:
index <- dplyr::filter(df, .data$z %in% (min(.data$z):lag))) %>% #some magic numbers - essentially we want to start at one behind the forecast + lag
dplyr::select(.data$y) %>% unlist()
#grab index value:
index <- dplyr::filter(df, .data$z %in% (min(.data$z):lag)) %>% #some magic numbers - essentially we want to start at one behind the forecast + lag
dplyr::select(.data$y) %>% unlist()
index
View(df_model)
x <- stats::diffinv(rev(df$x), lag = lag, xi = index)
x
x <- df_model$.fitted
x <- stats::diffinv((df$x), lag = lag, xi = index)
z
x
y
x <- df_model$.fitted
df = data.frame(x=x, y=y, z=z)
num_na = sum(is.na(x)) #this will count how many we need to avoid
na_vec <- rep(NA, num_na-1) #use this to regenerate correct vector at the end.
#grab index value:
index <- dplyr::filter(df, .data$z %in% (min(.data$z):lag)) %>% #some magic numbers - essentially we want to start at one behind the forecast + lag
dplyr::select(.data$y) %>% unlist()
df <- dplyr::filter(df, !is.na(.data$x))
x <- stats::diffinv((df$x), lag = lag, xi = index)
x
y
exp(x)
exp(y)
x <- stats::diffinv((df$x), lag = 1, xi = index)
x <- df_model$.fitted
x
x
diff(.data$y)
diff(df$y)
y2 = diff(y)
df = data.frame(x=x, y=y, y_diff = y_diff, z=z) %>%
dplyr::mutate(x = ifelse(is.na(.data$x, diff(.data$y), .data$x))) #impute missing x with y
y_diff = diff(y)
df = data.frame(x=x, y=y, y_diff = y_diff, z=z) %>%
dplyr::mutate(x = ifelse(is.na(.data$x, diff(.data$y), .data$x))) #impute missing x with y
y_diff
y_diff = c(NA, diff(y))
df = data.frame(x=x, y=y, y_diff = y_diff, z=z) %>%
dplyr::mutate(x = ifelse(is.na(.data$x, diff(.data$y), .data$x))) #impute missing x with y
df = data.frame(x=x, y=y, y_diff = y_diff, z=z) %>%
dplyr::mutate(x = ifelse(is.na(.data$x), .data$y_diff, .data$x)) #impute missing x with y
View(df)
#grab index value:
index <- dplyr::filter(df, .data$z %in% (min(.data$z))) %>% #some magic numbers - essentially we want to start at one behind the forecast + lag
dplyr::select(.data$y) %>% unlist()
index
x <- stats::diffinv((df$x), lag = 1, xi = index)
z
x
df <- dplyr::filter(df, !is.na(.data$x))
x <- stats::diffinv((df$x), lag = 1, xi = index)
x
exp(x)
exp(y)
devtools::load_all()
df_model <- Quandl::Quandl.datatable('SHARADAR/SEP', date.gte=min_date,
ticker= ticker1) %>%
dplyr::mutate(close_log = log(.data$close),
rank = rank(date))
#add model fit and forecast back to data frame
df_model <- predic_df %>% dplyr::left_join(df_model) %>%
dplyr::mutate(fitted_actual = exp(undiff(x= .data$.fitted,
y = .data$close_log,
z = .data$rank)),
fitted_log = undiff(x= .data$.fitted,
y = .data$close_log,
z = .data$rank),
hi_95 = exp(undiff(x = .data$hi_95,
y = .data$fitted_log,
z = .data$rank)),
lo_95 = exp(undiff(x= .data$lo_95,
y = .data$fitted_log,
z = .data$rank)),
hi_80 = exp(undiff(x= .data$hi_80,
y = .data$fitted_log,
z = .data$rank)),
lo_80 = exp(undiff(x= .data$lo_80,
y = .data$fitted_log,
z = .data$rank)))
View(df_model)
library(ggplot2)
ggplot(data = df_model, aes(x = date, y = close)) +
geom_point() + geom_line(aes(y = fitted_actual)) +
geom_ribbon(aes(ymin = lo_95, ymax = hi_95, alpha = 0.2))
ggplot(data = df_model, aes(x = date, y = fitted_actual)) +
geom_point(aes(y = close)) + geom_line(aes(y = fitted_actual)) +
geom_ribbon(aes(ymin = lo_95, ymax = hi_95, alpha = 0.2))
date <- Sys.Date()
df = df_model
max_rank = nrow(df_model) #gonna use this later to calculate new dates.
bizdays::add.bizdays(date, n = look_ahead)
bizday_sequence <- bizdays::bizseq(from = date, to = end_bizday)
end_bizday = bizdays::add.bizdays(date, n = look_ahead)
bizday_sequence <- bizdays::bizseq(from = date, to = end_bizday)
date + lubridate::days()
start_bizday = date + lubridate::days()
bizday_sequence <- bizdays::bizseq(from = start_bizday, to = end_bizday)
df$date[is.na(df$date)] <- bizday_sequence
View(df)
ggplot(data = df_model, aes(x = date, y = fitted_actual)) +
geom_point(aes(y = close)) + geom_line(aes(y = fitted_actual)) +
geom_ribbon(aes(ymin = lo_95, ymax = hi_95, alpha = 0.2))
devtools::load_all()
devtools::load_all()
devtools::load_all()
df_model <- add_dates(df_model, date = date, look_ahead = look_ahead)
devtools::load_all()
df_model <- Quandl::Quandl.datatable('SHARADAR/SEP', date.gte=min_date,
ticker= ticker1) %>%
dplyr::mutate(close_log = log(.data$close),
rank = rank(date))
#add model fit and forecast back to data frame
df_model <- predic_df %>% dplyr::left_join(df_model) %>%
dplyr::mutate(fitted_actual = exp(undiff(x= .data$.fitted,
y = .data$close_log,
z = .data$rank)),
fitted_log = undiff(x= .data$.fitted,
y = .data$close_log,
z = .data$rank),
hi_95 = exp(undiff(x = .data$hi_95,
y = .data$fitted_log,
z = .data$rank)),
lo_95 = exp(undiff(x= .data$lo_95,
y = .data$fitted_log,
z = .data$rank)),
hi_80 = exp(undiff(x= .data$hi_80,
y = .data$fitted_log,
z = .data$rank)),
lo_80 = exp(undiff(x= .data$lo_80,
y = .data$fitted_log,
z = .data$rank)))
df_model <- add_dates(df_model, date = date, look_ahead = look_ahead)
ggplot(data = df_model, aes(x = date, y = fitted_actual)) +
geom_point(aes(y = close)) + geom_line(aes(y = fitted_actual)) +
geom_ribbon(aes(ymin = lo_95, ymax = hi_95, alpha = 0.2))
?forecast::forecast
devtools::install()
devtools::install())
devtools::install()
devtools::document
devtools::document()
devtools::check()
usethis::use_gpl3_license()
devtools::check()
devtools::document()
devtools::load_all()
df_model <- renarin_short("DBX")
ggplot(data = df_model, aes(x = date, y = fitted_actual)) +
geom_point(aes(y = close)) + geom_line(aes(y = fitted_actual)) +
geom_ribbon(aes(ymin = lo_95, ymax = hi_95, alpha = 0.2))
library(ggplot2)
ggplot(data = df_model, aes(x = date, y = fitted_actual)) +
geom_point(aes(y = close)) + geom_line(aes(y = fitted_actual)) +
geom_ribbon(aes(ymin = lo_95, ymax = hi_95, alpha = 0.2))
df_model <- renarin_short("DBX", look_ahead = 30)
ggplot(data = df_model, aes(x = date, y = fitted_actual)) +
geom_point(aes(y = close)) + geom_line(aes(y = fitted_actual)) +
geom_ribbon(aes(ymin = lo_95, ymax = hi_95, alpha = 0.2))
ggplot(data = df_model, aes(x = date, y = fitted_actual)) +
geom_point(aes(y = close)) + geom_line(aes(y = fitted_actual)) #+
ticker = "VYGR"
vendor = "quandl"
look_back = 200
look_ahead = 14
lag = 10
decay = 0.2
ticker1 = ticker #just to avoid any bugs due to non-standard eval
date <- Sys.Date()
min_date <- date - lubridate::days(look_back)
key <- get_api_key(vendor = vendor)
Quandl::Quandl.api_key(key)
df_model <- Quandl::Quandl.datatable('SHARADAR/SEP', date.gte=min_date,
ticker= ticker1) %>%
dplyr::mutate(close_log = log(.data$close),
rank = rank(date))
#create differenced ts for modeling
ts_close <- diff(zoo::zoo(x = df_model$close_log, order.by = df_model$rank))
#don't want to try to fit if we don't have at least 80% of the points we wanted
if(length(ts_close) < 0.6*look_back) {
message(paste("not enough data to predict", ticker1, date))
return()
}
#fit the model and forecast
fit <- forecast::nnetar(y = ts_close, p = lag, P = 1, decay = decay)
fcast <- forecast::forecast(fit, h = look_ahead, PI=TRUE,
bootstrap = TRUE)
#tidy this shit up
predic_df <- process_fit(fit = fit, fcast = fcast, df = df_model,
look_ahead = look_ahead)
#add model fit and forecast back to data frame
df_model <- predic_df %>% dplyr::left_join(df_model) %>%
dplyr::mutate(fitted_actual = exp(undiff(x= .data$.fitted,
y = .data$close_log,
z = .data$rank)),
fitted_log = undiff(x= .data$.fitted,
y = .data$close_log,
z = .data$rank))
df = df_model
View(df_model)
df %>%
dplyr::mutate(hi_95 <- .data$hi_95*.data$fitted_actual + .data$fitted_actual)
df <- df %>%
dplyr::mutate(hi_95 <- .data$hi_95*.data$fitted_actual + .data$fitted_actual)
View(df)
df <- df %>%
dplyr::mutate(hi_95 = .data$hi_95*.data$fitted_actual + .data$fitted_actual)
df <- df %>%
dplyr::mutate(hi_95 = .data$hi_95*.data$fitted_actual + .data$fitted_actual,
hi_80 = .data$hi_80*.data$fitted_actual + .data$fitted_actual,
lo_80 = .data$lo_80*.data$fitted_actual + .data$fitted_actual,
lo_95 = .data$lo_95*.data$fitted_actual + .data$fitted_actual)
devtools::load_all()
df_model <- renarin_short("DBX", look_ahead = 30)
ggplot(data = df_model, aes(x = date, y = fitted_actual)) +
geom_point(aes(y = close)) + geom_line(aes(y = fitted_actual)) +
geom_ribbon(aes(ymin = lo_95, ymax = hi_95, alpha = 0.2))
View(df_model)
forecast_period <- df %>%
dplyr::filter(is.na(close))
View(forecast_period)
View(df)
final_price <- forecast_period %>%
dplyr::filter(rank = max(.data$rank)) %>%
select(.data$fitted_actual) %>% unlist()
final_price <- forecast_period %>%
dplyr::filter(rank = max(.data$rank)) %>%
dplyr::select(.data$fitted_actual) %>% unlist()
final_price <- forecast_period %>%
dplyr::filter(rank == max(.data$rank)) %>%
dplyr::select(.data$fitted_actual) %>% unlist()
index_price <- df %>%
dplyr::filter(!is.na(close)) %>%
dplyr::filter(rank = max(.data$rank)) %>%
dplyr::select(.data$close) %>% unlist()
index_price <- df %>%
dplyr::filter(!is.na(close)) %>%
dplyr::filter(rank == max(.data$rank)) %>%
dplyr::select(.data$close) %>% unlist()
10/8
8/10
20/8
8/10
1-8/10
tbl <- data.frame(index_price = index_price,
final_price = final_price,
max_price = max(forecast_period$fitted_actual),
min_price = min(forecast_period$fitted_actual)) %>%
dplyr::mutate(maximum_return = (.data$max_price/.data$index_price -1) * 100,
maximum_loss = (1 - .data$min_price/.data$index_price) * 100,
expected_return = ifelse(.data$final_price < .data$index_price,
(1- .data$final_price/.data$index_price) * 100,
(.data$final_price/.data$index_price - 1) * 100))
View(predic_df)
View(predic_df)
View(tbl)
1 - 10/8
1- 8/10
8/10 -1
tbl <- data.frame(index_price = index_price,
final_price = final_price,
max_price = max(forecast_period$fitted_actual),
min_price = min(forecast_period$fitted_actual)) %>%
dplyr::mutate(maximum_return = (.data$max_price/.data$index_price -1) * 100,
expected_return = (.data$final_price/.data$index_price -1) * 100)
tbl <- data.frame(index_price = index_price,
final_price = final_price,
max_price = max(forecast_period$fitted_actual),
min_price = min(forecast_period$fitted_actual)) %>%
dplyr::mutate(maximum_return = (.data$max_price/.data$index_price -1) * 100,
maximum_loss = (.data$min_price/.data$index_price - 1) * 100,
expected_return = (.data$final_price/.data$index_price -1) * 100)
devtools::load_all()
df_model <- renarin_short("DBX", look_ahead = 30, zoom_in = FALSE)
View(df_model)
install.packages("rvest")
devtools::install()
devtools::install()
View(forecast_period)
View(df_model)
devtools::install()
devtools::install()
devtools::load_all()
ticker = "ENPH"
vendor = "quandl"
look_back = 200
look_ahead = 14
lag = 10
decay = 0.2
zoom_in = FALSE
PI = FALSE
ticker1 = ticker #just to avoid any bugs due to non-standard eval
date <- Sys.Date()
min_date <- date - lubridate::days(look_back)
key <- get_api_key(vendor = vendor)
Quandl::Quandl.api_key(key)
df_model <- Quandl::Quandl.datatable('SHARADAR/SEP', date.gte=min_date,
ticker= ticker1) %>%
dplyr::mutate(close_log = log(.data$close),
rank = rank(date))
#create differenced ts for modeling
ts_close <- diff(zoo::zoo(x = df_model$close_log, order.by = df_model$rank))
#don't want to try to fit if we don't have at least 80% of the points we wanted
if(length(ts_close) < 0.6*look_back) {
message(paste("not enough data to predict", ticker1, date))
return()
}
#fit the model and forecast
fit <- forecast::nnetar(y = ts_close, p = lag, P = 1, decay = decay)
fcast <- forecast::forecast(fit, h = look_ahead, PI=PI,
bootstrap = TRUE)
#tidy this shit up
predic_df <- process_fit(fit = fit, fcast = fcast, df = df_model,
look_ahead = look_ahead)
#tidy this shit up
predic_df <- process_fit(fit = fit, fcast = fcast, df = df_model,
look_ahead = look_ahead, PI = PI)
View(predic_df)
#add model fit and forecast back to data frame
df_model <- predic_df %>% dplyr::left_join(df_model) %>%
dplyr::mutate(fitted_actual = exp(undiff(x= .data$.fitted,
y = .data$close_log,
z = .data$rank)),
fitted_log = undiff(x= .data$.fitted,
y = .data$close_log,
z = .data$rank))
View(df_model)
summarize_forecast(df_model)
devtools::install()
load_all()
devtools::load_all()
devtools::load_all()
ticker = "AAPL"
vendor = "yahoo"
look_back = 200
look_ahead = 14
lag =  10
decay = 0.2
zoom_in = TRUE
pi = FALSE
?tidyquant::tq_get
ticker1 = ticker #just to avoid any bugs due to non-standard eval
date <- Sys.Date()
min_date <- date - lubridate::days(look_back)
tidyquant::tq_get(x = ticker1, from = min_date)
tidyquant::tq_get(x = ticker1, from = min_date)

fcast_df$rank <- (nrow(fit_df)+1):nrow(df_model)
predic_df <- rbind(fit_df,fcast_df)
#add model fit and forecast back to data frame
df_model <- df_model %>% dplyr::left_join(predic_df)
View(df_model)
ggplot(data = df_model, aes(x = date, y = close_log)) +
geom_point(aes(color = training)) + geom_line(aes(y = .fitted))
library(ggplot2)
ggplot(data = df_model, aes(x = date, y = close_log)) +
geom_point(aes(color = training)) + geom_line(aes(y = .fitted))
?geom_ribbon
df <- df_model
mse <- mean(df_model$.resid[df_model$training == TRUE])^2
View(df_model)
geom_ribbon
?geom_ribbon
ggplot(data = df_model, aes(x = date, y = close_log)) +
geom_point(aes(color = training)) + geom_line(aes(y = .fitted)) +
geom_ribbon(aes(ymin = lo_95, ymax = hi_95, alpha = 0.2))
View(df)
forecast_df <- df %>% dplyr::filter(.data$training == FALSE)
View(forecast_df)
forecast_df <- df %>% dplyr::filter(.data$training == FALSE) %>%
mutate(fitted_actual = exp(.data$.fitted),
resid = .data$close - .data$.fitted)
#first move limit to the forecast points
forecast_df <- df %>% dplyr::filter(.data$training == FALSE) %>%
dplyr::mutate(fitted_actual = exp(.data$.fitted),
resid = .data$close - .data$.fitted)
#first move limit to the forecast points
forecast_df <- df %>% dplyr::filter(.data$training == FALSE) %>%
dplyr::mutate(fitted_actual = exp(.data$.fitted),
resid = .data$close - .data$fitted_actual)
mse <- mean(forecast_df$resid)^2
mse <- mean(forecast_df$resid^2)
mae <- max(forecast_df$resid)
#first move limit to the forecast points
forecast_df <- df %>% dplyr::filter(.data$training == FALSE) %>%
dplyr::mutate(fitted_actual = exp(.data$.fitted),
resid = .data$fitted_actual - .data$close)
mse <- mean(forecast_df$resid^2)
mae <- max(forecast_df$resid)
last_point <- forecast_df %>% dplyr::filter(.data$date == max(.data$date))
View(last_point)
sum_tbl <- forecast_df %>%
dplyr::summarise(mse = mean(.data$resid^2),
mae = max(.data$resid)) %>%
dplyr::mutate(above_median = (last_point$close_log > last_point$point_forecast),
below_median = (last_point$close_log < last_point$point_forecast),
within_80 = (last_point$close_log < last_point$hi_80 &
last_point$close_log > last_point$lo_80),
within_95 = (last_point$close_log < last_point$hi_95 &
last_point$close_log > last_point$lo_95) )
View(sum_tbl)
sum_tbl <- forecast_df %>%
dplyr::summarise(mse = mean(.data$resid^2),
mae = max(.data$resid)) %>%
dplyr::mutate(above_median = (last_point$close_log > last_point$point_forecast),
below_median = (last_point$close_log < last_point$point_forecast),
within_80 = (last_point$close_log < last_point$hi_80 &
last_point$close_log > last_point$lo_80),
within_95 = (last_point$close_log < last_point$hi_95 &
last_point$close_log > last_point$lo_95),
close = last_point$close,
close_forecast = last_point$fitted_actual,
close_hi95 = exp(last_point$hi_95),
close_lo95 = exp(last_point$lo_95))
library(devtools)
document()
load(file = "G:/My Drive/pkg/data/sharadar/AAPL_SEP.csv")
load(file = "G:/My Drive/pkg/data/sharadar/VYGR_SEP.csv")
load(file = "G:/My Drive/pkg/data/sharadar/TRV_SEP.csv")
#time_vec
time_aapl <- as.Date(df_aapl$date)
time_test <- sample(time_aapl, size = 1)
#start with the raw data
df_sep_raw <- read_csv("G:/My Drive/pkg/data/sharadar/SHARADAR_SEP.csv")
#start with the raw data
df_sep_raw <- readr::read_csv("G:/My Drive/pkg/data/sharadar/SHARADAR_SEP.csv")
load_all()
renarin_short_historic(ticker = "AAPL", date = time_test, df = df_sep_raw, look_back = 30, look_ahead = 7)
ticker = "AAPL"
df = df_sep_raw
look_back = 30
look_ahead = 7
date = time_test
#first filter data frame down to the specified date range
max_date <- date + lubridate::days(look_ahead)
min_date <- date - lubridate::days(look_back)
View(df_trv)
df_model <- df %>%
dplyr::filter(.data$ticker == ticker,
.data$date >= min_date & .data$date <= max_date) %>%
dplyr::mutate(close_log = log(.data$close),
rank = rank(date))
View(df_model)
sum(df_model$ticker == ticker)
library(magrittr)
test <- df %>% dplyr::filter(.data$ticker == ticker)
ticker
test <- df %>% dplyr::filter(.data$ticker == "AAPL")
ticker
unlist(ticker)
#need to rename user-provided ticker because the dplyr non-standard evaluation gets confused
ticker1 <- ticker
df_model <- df %>%
dplyr::filter(.data$ticker == ticker1,
.data$date >= min_date & .data$date <= max_date) %>%
dplyr::mutate(close_log = log(.data$close),
rank = rank(date))
#start with the raw data
df_sep_raw <- readr::read_csv("G:/My Drive/pkg/data/sharadar/SHARADAR_SEP.csv")
library(devtools)
load_all()
load(file = "G:/My Drive/pkg/data/sharadar/AAPL_SEP.csv")
time_test <- sample(time_aapl, size = 1)
#time_vec
time_aapl <- as.Date(df_aapl$date)
time_test <- sample(time_aapl, size = 1)
renarin_short_historic(ticker = "AAPL", date = time_test, df = df_aapl)
install()
install()
use_r("utils")
use_test()
ticker = "AAPL"
df = df_sep_raw
#start with the raw data
df_sep_raw <- readr::read_csv("G:/My Drive/pkg/data/sharadar/SHARADAR_SEP.csv")
install.packages("rlang")
install.packages("rlang")
install.packages("devtools")
devtools::install()
#start with the raw data
df_sep_raw <- readr::read_csv("G:/My Drive/pkg/data/sharadar/SHARADAR_SEP.csv")
df <- df_sep_raw
ticker = "AAPL"
num_times = 100
ticker1 <- ticker
df_ticker <- dplyr::filter(df, .data$ticker == ticker1)
time_vec <- df_ticker$date
date_vec <- df_ticker$date
df_ticker <- dplyr::filter(df, .data$ticker == ticker1) %>%
dplyr::mutate(year = lubridate::year(date))
library(magrittr)
df_ticker <- dplyr::filter(df, .data$ticker == ticker1) %>%
dplyr::mutate(year = lubridate::year(date))
View(df_ticker)
?dplyr::slice_sample
df_ticker <- dplyr::filter(df, .data$ticker == ticker1) %>%
dplyr::mutate(year = lubridate::year(.data$date),
month = lubridate::month(.data$date)) %>%
dplyr::group_by(.data$year, .data$month) %>%
dplyr::slice_sample(n = (num_times))
num_times = 1
df_ticker <- dplyr::filter(df, .data$ticker == ticker1) %>%
dplyr::mutate(year = lubridate::year(.data$date),
month = lubridate::month(.data$date)) %>%
dplyr::group_by(.data$year, .data$month) %>%
dplyr::slice_sample(n = num_times)
View(df_ticker)
date_vec <- df_ticker$date
return(date_vec)
install()
devtools::install()
devtools::install()
devtools::load_all()
document()
devtools::document()
devtools::document()
devtools::install()
install()
devtools::install()
#start with the raw data
df_sep_raw <- readr::read_csv("G:/My Drive/pkg/data/sharadar/SHARADAR_SEP.csv")
ticker = 'TSLA'
date = as.date("2010-06-30")
date = as.Date("2010-06-30")
look_back = 30
look_ahead = 7
df = df_sep_raw
#first filter data frame down to the specified date range
max_date <- date + lubridate::days(look_ahead)
min_date <- date - lubridate::days(look_back)
#need to rename user-provided ticker because the dplyr non-standard evaluation gets confused
ticker1 <- ticker
df_model <- df %>%
dplyr::filter(.data$ticker == ticker1,
.data$date >= min_date & .data$date <= max_date) %>%
dplyr::mutate(close_log = log(.data$close),
rank = rank(date))
View(df_model)
date = 2012-06-30
date = as.Date("2012-06-30")
#first filter data frame down to the specified date range
max_date <- date + lubridate::days(look_ahead)
min_date <- date - lubridate::days(look_back)
#need to rename user-provided ticker because the dplyr non-standard evaluation gets confused
ticker1 <- ticker
df_model <- df %>%
dplyr::filter(.data$ticker == ticker1,
.data$date >= min_date & .data$date <= max_date) %>%
dplyr::mutate(close_log = log(.data$close),
rank = rank(date))
#add logical vec for training
df_model$training <- (df_model$date <= date)
#create zoo ts
df_model_train <- dplyr::filter(df_model, .data$training == TRUE)
ts_close <- (zoo::zoo(x = df_model_train$close_log, order.by = df_model_train$rank))
?forecast::nnetar
ts_close <- (zoo::zoo(x = df_model_train$close_log, order.by = df_model_train$rank))
#fit all the training points.
fit <- forecast::nnetar(y = ts_close, p = 5, P = 1)
fcast <- forecast::forecast(fit, h = sum(df_model$training == FALSE), PI=TRUE,
bootstrap = TRUE)
#put together tidy data frame of model output
fit_df <- sweep::sw_augment(fit)
colnames(fit_df)[colnames(fit_df) == "index"] <- "rank"
fit_df <- fit_df %>%
dplyr::mutate(point_forecast = NA,
lo_80 = NA, hi_80 = NA,
lo_95 = NA, hi_95 = NA)
#tidy up forecast output.
fcast_df <- as.data.frame(fcast) %>% janitor::clean_names()
fcast_df$rank <- (nrow(fit_df)+1):nrow(df_model)
fcast_df <- fcast_df %>%
dplyr::mutate(`.actual` = NA,
`.fitted` = .data$point_forecast,
`.resid` = NA)
predic_df <- rbind(fit_df,fcast_df)
#add model fit and forecast back to data frame
df_model <- df_model %>% dplyr::left_join(predic_df)
ggplot(data = df_model, aes(x = date, y = close_log)) +
geom_point(aes(color = training)) + geom_line(aes(y = .fitted)) +
geom_ribbon(aes(ymin = lo_95, ymax = hi_95, alpha = 0.2))
library(ggplot2)
ggplot(data = df_model, aes(x = date, y = close_log)) +
geom_point(aes(color = training)) + geom_line(aes(y = .fitted)) +
geom_ribbon(aes(ymin = lo_95, ymax = hi_95, alpha = 0.2))
look_back = 60
#first filter data frame down to the specified date range
max_date <- date + lubridate::days(look_ahead)
min_date <- date - lubridate::days(look_back)
#need to rename user-provided ticker because the dplyr non-standard evaluation gets confused
ticker1 <- ticker
df_model <- df %>%
dplyr::filter(.data$ticker == ticker1,
.data$date >= min_date & .data$date <= max_date) %>%
dplyr::mutate(close_log = log(.data$close),
rank = rank(date))
#add logical vec for training
df_model$training <- (df_model$date <= date)
#create zoo ts
df_model_train <- dplyr::filter(df_model, .data$training == TRUE)
ts_close <- (zoo::zoo(x = df_model_train$close_log, order.by = df_model_train$rank))
#fit all the training points.
fit <- forecast::nnetar(y = ts_close, p = 10, P = 1)
fcast <- forecast::forecast(fit, h = sum(df_model$training == FALSE), PI=TRUE,
bootstrap = TRUE)
#put together tidy data frame of model output
fit_df <- sweep::sw_augment(fit)
colnames(fit_df)[colnames(fit_df) == "index"] <- "rank"
fit_df <- fit_df %>%
dplyr::mutate(point_forecast = NA,
lo_80 = NA, hi_80 = NA,
lo_95 = NA, hi_95 = NA)
#tidy up forecast output.
fcast_df <- as.data.frame(fcast) %>% janitor::clean_names()
fcast_df$rank <- (nrow(fit_df)+1):nrow(df_model)
fcast_df <- fcast_df %>%
dplyr::mutate(`.actual` = NA,
`.fitted` = .data$point_forecast,
`.resid` = NA)
predic_df <- rbind(fit_df,fcast_df)
#add model fit and forecast back to data frame
df_model <- df_model %>% dplyr::left_join(predic_df)
ggplot(data = df_model, aes(x = date, y = close_log)) +
geom_point(aes(color = training)) + geom_line(aes(y = .fitted)) +
geom_ribbon(aes(ymin = lo_95, ymax = hi_95, alpha = 0.2))
source('G:/My Drive/pkg/stonkr/R/short_term.R')
#fit all the training points.
fit <- forecast::nnetar(y = ts_close, p = 7, P = 1, decay = 0.2)
fcast <- forecast::forecast(fit, h = sum(df_model$training == FALSE), PI=TRUE,
bootstrap = TRUE)
#put together tidy data frame of model output
fit_df <- sweep::sw_augment(fit)
colnames(fit_df)[colnames(fit_df) == "index"] <- "rank"
fit_df <- fit_df %>%
dplyr::mutate(point_forecast = NA,
lo_80 = NA, hi_80 = NA,
lo_95 = NA, hi_95 = NA)
#tidy up forecast output.
fcast_df <- as.data.frame(fcast) %>% janitor::clean_names()
fcast_df$rank <- (nrow(fit_df)+1):nrow(df_model)
fcast_df <- fcast_df %>%
dplyr::mutate(`.actual` = NA,
`.fitted` = .data$point_forecast,
`.resid` = NA)
predic_df <- rbind(fit_df,fcast_df)
#add model fit and forecast back to data frame
df_model <- df_model %>% dplyr::left_join(predic_df)
ggplot(data = df_model, aes(x = date, y = close_log)) +
geom_point(aes(color = training)) + geom_line(aes(y = .fitted)) +
geom_ribbon(aes(ymin = lo_95, ymax = hi_95, alpha = 0.2))
df_model <- df %>%
dplyr::filter(.data$ticker == ticker1,
.data$date >= min_date & .data$date <= max_date) %>%
dplyr::mutate(close_log = log(.data$close),
rank = rank(date))
#add logical vec for training
df_model$training <- (df_model$date <= date)
#create zoo ts
df_model_train <- dplyr::filter(df_model, .data$training == TRUE)
ts_close <- (zoo::zoo(x = df_model_train$close_log, order.by = df_model_train$rank))
#fit all the training points.
fit <- forecast::nnetar(y = ts_close, p = ,6 P = 1, decay = 0.2)
fcast <- forecast::forecast(fit, h = sum(df_model$training == FALSE), PI=TRUE,
bootstrap = TRUE)
fit_df <- sweep::sw_augment(fit)
colnames(fit_df)[colnames(fit_df) == "index"] <- "rank"
fit_df <- fit_df %>%
dplyr::mutate(point_forecast = NA,
lo_80 = NA, hi_80 = NA,
lo_95 = NA, hi_95 = NA)
#tidy up forecast output.
fcast_df <- as.data.frame(fcast) %>% janitor::clean_names()
fcast_df$rank <- (nrow(fit_df)+1):nrow(df_model)
fcast_df <- fcast_df %>%
dplyr::mutate(`.actual` = NA,
`.fitted` = .data$point_forecast,
`.resid` = NA)
predic_df <- rbind(fit_df,fcast_df)
#add model fit and forecast back to data frame
df_model <- df_model %>% dplyr::left_join(predic_df)
?dplyr::left_join
ggplot(data = df_model, aes(x = date, y = close_log)) +
geom_point(aes(color = training)) + geom_line(aes(y = .fitted)) +
geom_ribbon(aes(ymin = lo_95, ymax = hi_95, alpha = 0.2))
lag = 6
devtools::install()
devtools::install()
rm(list = ls())
devtools::install()
cumsum()
?cumsum
devtools::install()
#start with the raw data
df_sep_raw <- readr::read_csv("G:/My Drive/pkg/data/sharadar/SHARADAR_SEP.csv")
ticker = "AAPL"
date = as.Date("06-20-2020")
date = as.Date("06-21-2020")
load(file = "G:/My Drive/pkg/data/sharadar/AAPL_SEP.csv")
#time_vec
time_aapl <- as.Date(df_aapl$date)
date = as.Date("2020-06-20")
look_back = 200
look_ahead = 7
zoom_in = FALSE
lag = 20
decay = 0.2
look_ahead = 14
#first filter data frame down to the specified date range
max_date <- date + lubridate::days(look_ahead)
min_date <- date - lubridate::days(look_back)
#need to rename user-provided ticker because the dplyr non-standard evaluation gets confused
ticker1 <- ticker
df_model <- df %>%
dplyr::filter(.data$ticker == ticker1,
.data$date >= min_date & .data$date <= max_date) %>%
dplyr::mutate(close_log = log(.data$close),
rank = rank(date))
df <- df_sep_raw
df_model <- df %>%
dplyr::filter(.data$ticker == ticker1,
.data$date >= min_date & .data$date <= max_date) %>%
dplyr::mutate(close_log = log(.data$close),
rank = rank(date))
#add logical vec for training
df_model$training <- (df_model$date <= date)
#create zoo ts
df_model_train <- dplyr::filter(df_model, .data$training == TRUE)
ts_close <- diff(zoo::zoo(x = df_model_train$close_log, order.by = df_model_train$rank))
ts_close
#fit all the training points.
fit <- forecast::nnetar(y = ts_close, p = lag, P = 1, decay = decay)
fcast <- forecast::forecast(fit, h = sum(df_model$training == FALSE), PI=TRUE,
bootstrap = TRUE)
#put together tidy data frame of model output
fit_df <- sweep::sw_augment(fit)
fit_df
match_df <- data.frame(index = 1, .actual = NA, .fitted = NA, .resid = NA)
fit_df <- rbind(match_df, fit_df)
fit_df
#tidy up forecast output.
fcast_df <- as.data.frame(fcast) %>% janitor::clean_names()
fcast_df$rank <- (nrow(fit_df)+1):nrow(df_model)
fcast_df <- fcast_df %>%
dplyr::mutate(`.actual` = NA,
`.fitted` = .data$point_forecast,
`.resid` = NA)
predic_df <- rbind(fit_df, fcast_df)
colnames(fit_df)[colnames(fit_df) == "index"] <- "rank"
fit_df <- fit_df %>%
dplyr::mutate(point_forecast = NA,
lo_80 = NA, hi_80 = NA,
lo_95 = NA, hi_95 = NA)
predic_df <- rbind(fit_df, fcast_df)
#add model fit and forecast back to data frame
df_model <- df_model %>% dplyr::left_join(predic_df)
View(df_model)
out <- summarize_forecast(df_model)
devtools::load_all()
out <- summarize_forecast(df_model)
out
View(df_model)
#add model fit and forecast back to data frame
df_model <- df_model %>% dplyr::left_join(predic_df) %>%
dplyr::mutate(fitted_actual = cumsum(.data$close) + exp(.data$.fitted))
#add model fit and forecast back to data frame
df_model <- df_model %>% dplyr::left_join(predic_df) %>%
dplyr::mutate(fitted_actual = .data$close + exp(.data$.fitted))
#add model fit and forecast back to data frame
df_model <- df_model %>% dplyr::left_join(predic_df) %>%
dplyr::mutate(fitted_actual = .data$close + exp(.data$.fitted),
hi95 = .data$close + exp(.data$hi95),
lo95 = .data$close + exp(.data$lo95),
hi80 = .data$close + exp(.data$hi80),
lo80 = .data$close + exp(.data$lo80))
#add model fit and forecast back to data frame
df_model <- df_model %>% dplyr::left_join(predic_df) %>%
dplyr::mutate(fitted_actual = .data$close + exp(.data$.fitted),
hi_95 = .data$close + exp(.data$hi_95),
lo_95 = .data$close + exp(.data$lo_95),
hi_80 = .data$close + exp(.data$hi_80),
lo_80 = .data$close + exp(.data$lo_80))
ggplot(data = df_model, aes(x = date, y = close)) +
geom_point(aes(color = training)) + geom_line(aes(y = fitted_actual)) +
geom_ribbon(aes(ymin = lo_95, ymax = hi_95, alpha = 0.2))
load_all()
devtools::load_all()
out <- summarize_forecast(df_model)
out
devtools::install()
?diffinv
#time_vec
time_aapl <- as.Date(df_aapl$date)
load(file = "G:/My Drive/pkg/data/sharadar/AAPL_SEP.csv")
#time_vec
time_aapl <- as.Date(df_aapl$date)
time_test <- sample(time_aapl, size = 1)
ticker = "AAPL"
df = df_aapl
date = time_test
look_back = 90
look_ahead = 14
look_back = 300
decay = 0.2
lag = 10
#first filter data frame down to the specified date range
max_date <- date + lubridate::days(look_ahead)
min_date <- date - lubridate::days(look_back)
#need to rename user-provided ticker because the dplyr non-standard evaluation gets confused
ticker1 <- ticker
df_model <- df %>%
dplyr::filter(.data$ticker == ticker1,
.data$date >= min_date & .data$date <= max_date) %>%
dplyr::mutate(close_log = log(.data$close),
rank = rank(date))
library(magrittr)
df_model <- df %>%
dplyr::filter(.data$ticker == ticker1,
.data$date >= min_date & .data$date <= max_date) %>%
dplyr::mutate(close_log = log(.data$close),
rank = rank(date))
#add logical vec for training
df_model$training <- (df_model$date <= date)
#create zoo ts
df_model_train <- dplyr::filter(df_model, .data$training == TRUE)
ts_close <- diff(zoo::zoo(x = df_model_train$close_log, order.by = df_model_train$rank))
#fit all the training points.
fit <- forecast::nnetar(y = ts_close, p = lag, P = 1, decay = decay)
fcast <- forecast::forecast(fit, h = sum(df_model$training == FALSE), PI=TRUE)
#put together tidy data frame of model output
fit_df <- sweep::sw_augment(fit)
match_df <- data.frame(index = 1, .actual = NA, .fitted = NA, .resid = NA)
fit_df <- rbind(match_df, fit_df) #have to do this step because the differencing step fucks it.
colnames(fit_df)[colnames(fit_df) == "index"] <- "rank"
fit_df <- fit_df %>%
dplyr::mutate(point_forecast = NA,
lo_80 = NA, hi_80 = NA,
lo_95 = NA, hi_95 = NA)
#tidy up forecast output.
fcast_df <- as.data.frame(fcast) %>% janitor::clean_names()
fcast_df$rank <- (nrow(fit_df)+1):nrow(df_model)
fcast_df <- fcast_df %>%
dplyr::mutate(`.actual` = NA,
`.fitted` = .data$point_forecast,
`.resid` = NA)
predic_df <- rbind(fit_df, fcast_df)
View(predic_df)
diffinv(ts_close)
#add model fit and forecast back to data frame
df_model <- df_model %>% dplyr::left_join(predic_df) %>%
dplyr::mutate(fitted_actual = exp(diffinv(.data$.fitted)),
hi_95 = .data$close + exp(.data$hi_95),
lo_95 = .data$close + exp(.data$lo_95),
hi_80 = .data$close + exp(.data$hi_80),
lo_80 = .data$close + exp(.data$lo_80))
exp(diffinv(predic_df$.fitted))
#add model fit and forecast back to data frame
df_model <- df_model %>% dplyr::left_join(predic_df) #%>%
View(df_model)
as.ts(ts_close)
